// Created by AJ DiLeo
// For use in CS211 Spring 2024 ONLY

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <time.h>

#define MAX_INPUT_SIZE 1024
#define MAX_ARGS_SIZE 100

typedef struct team {
	int id;
	char* name;
	int yearFounded;
	char* city;
	char* sport;
	double popularityIndex;

	int isDeleted; // internal field, not directly accessible to user
} team_t;

// step 1: create structs for the other two tables: athletes
// and competitions
// include internal field
typedef struct athlete {
	int id;
	char* name;
	int birthYear;
	char* nationality;
	char* sport;
	int isDeleted;
}athlete_t;

typedef struct competition {
	int id;
	char* name;
	int year;
	char* sport;
	char* location;
	int isDeleted;
}competition_t;
// step 2: create typedef struct for storing metadata
typedef struct metadata{
	int count;
	int nextIndex;
	int maxCount;
}metadata_t;
// step 3: declare the two other arrays of structs
// teams has been defined for you already
// TODO: add athletes and competitions
team_t* teams;
athlete_t* athletes;
competition_t* competitions;

// step 4: declare 3 metadata structs, one for each table
metadata_t teamsMetadata = { .count = 0, .nextIndex = 0, .maxCount = 0 };
metadata_t athletesMetadata = { .count = 0, .nextIndex = 0, .maxCount = 0 };
metadata_t competitionsMetadata = { .count = 0, .nextIndex = 0, .maxCount = 0 };
// step 5: jump to L167


// This function takes the user's input and splits it by spaces
// into an array of strings, ignoring spaces that are wrapped in quotes
// There is no need to modify this code.
// You do not need to understand this code
// but you are welcome to research its application
void splitInput(char* input, char** args, int* arg_count) {
    *arg_count = 0;
    int in_quotes = 0; // Flag to track whether we are inside quotes
    char* token_start = input;

    for (char* ptr = input; *ptr != '\0'; ptr++) {
        if (*ptr == '"') {
            in_quotes = !in_quotes; // Toggle the in_quotes flag when a quote is encountered
        }

        if ((*ptr == ' ' || *ptr == '\n') && !in_quotes) {
            // If not inside quotes and a space or newline is found, consider it as a separator
            *ptr = '\0'; // Replace space or newline with null terminator
            args[(*arg_count)++] = token_start;
            token_start = ptr + 1; // Start of the next token
        }
    }

    // Add the last token (if any) after the loop
    if (*token_start != '\0') {
        // Remove leading and trailing double quotes if they exist
        if (token_start[0] == '"' && token_start[strlen(token_start) - 1] == '"') {
            token_start[strlen(token_start) - 1] = '\0'; // Remove trailing quote
            args[(*arg_count)++] = token_start + 1; // Remove leading quote
        } else {
            args[(*arg_count)++] = token_start;
        }
    }
    args[*arg_count] = NULL;
}

// step 7: implement setup function
// this function is responsible for dynamically allocating the
// particular table. Use the tables declared on L27.
void setup(char* table, int numRows) {
	if (strcmp(table, "teams") == 0) {
		teams = (team_t*)malloc(numRows * sizeof(team_t));
		teamsMetadata.maxCount = numRows;
	}
	if (strcmp(table, "athletes") == 0){
		athletes = (athlete_t*)malloc(numRows * sizeof(athlete_t));
		athletesMetadata.maxCount = numRows;
	}
	if (strcmp(table, "competitions") == 0){
		competitions = (competition_t*)malloc(numRows * sizeof(competition_t));
		competitionsMetadata.maxCount = numRows;
	}
	// DO NOT TOUCH THIS PRINT
	// REQUIRED FOR AUTOGRADER
	printf("setup complete\n");
}

// step 8: implement insert function
// this function is responsible for updating the corresponding
// fields of the struct located at the next available index
// make sure to use and update your metadata.

// autograder print for insufficient capacity:
// fprintf(stderr, "cannot insert due to insufficient capacity.\n");
void insert(char** args) {
    char* table = args[1];
    int index;

    if (strcmp(table, "teams") == 0) {
        index = teamsMetadata.nextIndex;
    } else if (strcmp(table, "athletes") == 0) {
        index = athletesMetadata.nextIndex;
    } else if (strcmp(table, "competitions") == 0) {
        index = competitionsMetadata.nextIndex;
    }

    if (index >= teamsMetadata.maxCount || index >= athletesMetadata.maxCount || index >= competitionsMetadata.maxCount) {
        fprintf(stderr, "cannot insert due to insufficient capacity.\n");
        return;
    }

    if (strcmp(table, "teams") == 0) {
        teams[index].id = index;
        teams[index].name = strdup(args[3]);
        teams[index].yearFounded = atoi(args[4]);
        teams[index].city = strdup(args[5]);
        teams[index].sport = strdup(args[6]);
        teams[index].popularityIndex = atof(args[7]);
        teams[index].isDeleted = 0; // Initialize the isDeleted field
    } else if (strcmp(table, "athletes") == 0) {
        athletes[index].id = index;
        athletes[index].name = strdup(args[3]);
        athletes[index].birthYear = atoi(args[4]);
        athletes[index].nationality = strdup(args[5]);
        athletes[index].sport = strdup(args[6]);
        athletes[index].isDeleted = 0; // Initialize the isDeleted field
    } else if (strcmp(table, "competitions") == 0) {
        competitions[index].id = index;
        competitions[index].name = strdup(args[3]);
        competitions[index].year = atoi(args[4]);
        competitions[index].sport = strdup(args[5]);
        competitions[index].location = strdup(args[6]);
        competitions[index].isDeleted = 0; // Initialize the isDeleted field
    }

    if (strcmp(table, "teams") == 0) {
        teamsMetadata.count++;
        teamsMetadata.nextIndex++;
    } else if (strcmp(table, "athletes") == 0) {
        athletesMetadata.count++;
        athletesMetadata.nextIndex++;
    } else if (strcmp(table, "competitions") == 0) {
        competitionsMetadata.count++;
        competitionsMetadata.nextIndex++;
    }

    // DO NOT TOUCH THIS PRINT
    // REQUIRED FOR AUTOGRADER
    printf("insert complete\n");
}


// step 9: implement soft delete function
// this function is responsible for marking a record as deleted
// you should be updating an internal field flag so that get will
// not display this record. 
// You should not be attempting to free/overwrite this record - it remains alloc
// with a updated field
// make use of your metadata
void delete(char* table, int id) {
	int index;
	
	if (strcmp(table, "teams") == 0){
		index = id;
	} else if (strcmp(table, "athletes") == 0){
		index = id;
	} else if (strcmp(table, "competitions") == 0){
		index = id;
	}
	
	if (strcmp(table, "teams") == 0 && index < teamsMetadata.maxCount){
    		teams[index].isDeleted = 1;
	} else if (strcmp(table, "athletes") == 0 && index < athletesMetadata.maxCount){
    		athletes[index].isDeleted = 1;
	} else if (strcmp(table, "competitions") == 0 && index < competitionsMetadata.maxCount){
   		competitions[index].isDeleted = 1;
	}


	// DO NOT TOUCH THIS PRINT
	// REQUIRED FOR AUTOGRADER
	printf("delete complete\n");
}

// step 10: implement modify function
// this function is responsible for overwriting all of the contents of all
// records that match an ID.
// make use of your metadata
// !!!NOTE: The structs store pointers. Make sure to free any allocated
// memory before overwriting it!!!
void modify(char** args) {
	char* table = args[1];
    	int id = atoi(args[2]);
    	int index;

    	if (strcmp(table, "teams") == 0) {
        	index = id;
    	} else if (strcmp(table, "athletes") == 0) {
        	index = id;
    	} else if (strcmp(table, "competitions") == 0) {
        	index = id;
    	}

    	if (index < 0 || index >= teamsMetadata.maxCount) {
        	fprintf(stderr, "Invalid index for modification.\n");
        	return;
    	}

    	if (strcmp(table, "teams") == 0) {
        	free(teams[index].name);
        	free(teams[index].city);
        	free(teams[index].sport);

        	teams[index].name = strdup(args[3]);
        	teams[index].yearFounded = atoi(args[4]);
        	teams[index].city = strdup(args[5]);
        	teams[index].sport = strdup(args[6]);
        	teams[index].popularityIndex = atof(args[7]);

		teamsMetadata.count++;
    		teamsMetadata.nextIndex++;

    	} else if (strcmp(table, "athletes") == 0) {
        	free(athletes[index].name);
        	free(athletes[index].nationality);
        	free(athletes[index].sport);

        	athletes[index].name = strdup(args[3]);
        	athletes[index].birthYear = atoi(args[4]);
        	athletes[index].nationality = strdup(args[5]);
        	athletes[index].sport = strdup(args[6]);

		athletesMetadata.count++;
    		athletesMetadata.nextIndex++;
    	} else if (strcmp(table, "competitions") == 0) {
        	free(competitions[index].name);
        	free(competitions[index].location);
        	free(competitions[index].sport);

        	competitions[index].name = strdup(args[3]);
        	competitions[index].year = atoi(args[4]);
        	competitions[index].location = strdup(args[5]);
        	competitions[index].sport = strdup(args[6]);

		competitionsMetadata.count++;
    		competitionsMetadata.nextIndex++;
    	}

    	if (strcmp(table, "teams") == 0 && teams[index].isDeleted) {
        	teams[index].isDeleted = 0;
    	} else if (strcmp(table, "athletes") == 0 && athletes[index].isDeleted) {
        	athletes[index].isDeleted = 0;
    	} else if (strcmp(table, "competitions") == 0 && competitions[index].isDeleted) {
       		competitions[index].isDeleted = 0;
    	}
	// DO NOT TOUCH THIS PRINT
	// REQUIRED FOR AUTOGRADER
	printf("modify complete\n");
}

// step 11: implement get function
// this function is responsible for fetching all non-deleted records
// make use of your metadata
// Make sure to follow guidelines for format in writeup
// see examples as well
// Use %lf for formatting double data type
void get(char* table) {	
	int index;
	if (strcmp(table, "teams") == 0){
		index = teamsMetadata.nextIndex;
		printf("id, name, yearFounded, city, sport, popularityIndex\n");
		for (int i = 0; i < index; i++) {
            		if (!teams[i].isDeleted) {
                		printf("%d, %s, %d, %s, %s, %lf\n", teams[i].id, teams[i].name, teams[i].yearFounded, teams[i].city, teams[i].sport, teams[i].popularityIndex);
            		}
        	}
	} else 	if (strcmp(table, "athletes") == 0){
		index = athletesMetadata.nextIndex;
		printf("id, name, birthYear, nationality, sport\n");
		for (int i = 0; i < index; i++) {
            		if (!athletes[i].isDeleted) {
                		printf("%d, %s, %d, %s, %s\n", athletes[i].id, athletes[i].name, athletes[i].birthYear, athletes[i].nationality, athletes[i].sport);
            		}
        	}
			
	} else 	if (strcmp(table, "competitions") == 0){
		index = competitionsMetadata.nextIndex;
		printf("id, name, year, sport, location\n");
		for (int i = 0; i < index; i++) {
            		if (!competitions[i].isDeleted) {
                		printf("%d, %s, %d, %s, %s\n", competitions[i].id, competitions[i].name, competitions[i].year, competitions[i].sport, competitions[i].location);
            		}
        	}
			
	}
}

// step 12: implement exit function
// this function should free all allocated memory
// Make sure to avoid memory leaks by freeing any allocated memory
// inside a struct (char*) before freeing the struct pointer
void exitProgram() {
    	for (int i = 0; i < teamsMetadata.maxCount; i++) {
        	free(teams[i].name);
        	free(teams[i].city);
        	free(teams[i].sport);
    	}
    	free(teams);

    	for (int i = 0; i < athletesMetadata.maxCount; i++) {
        	free(athletes[i].name);
        	free(athletes[i].nationality);
        	free(athletes[i].sport);
    	}
    	free(athletes);

    	for (int i = 0; i < competitionsMetadata.maxCount; i++) {
        	free(competitions[i].name);
	        free(competitions[i].location);
	        free(competitions[i].sport);
	}
	free(competitions);

    	printf("exit complete\n");
}

// this code is responsible for parsing the user's
// input, and determining based on the command
// which function to send it to.
// You do not have to modify this code, but you should
// understand it.
void execute_cmd(char** args, int arg_count) {
	char* cmd = args[0];
	if (strcmp(cmd, "setup") == 0) {
		setup(args[1], atoi(args[2]));
	} else if (strcmp(cmd, "insert") == 0) {
		insert(args);
	} else if (strcmp(cmd, "delete") == 0) {
		delete(args[1], atoi(args[2]));
	} else if (strcmp(cmd, "modify") == 0) {
		modify(args);
	} else if (strcmp(cmd, "get") == 0) {
		get(args[1]);
	} else if (strcmp(cmd, "exit") == 0) {
		exitProgram();
	} else {
		printf("\n");
	}
}

// step 6: initialize the default metadata values here
// jump to L76
void initializeMetadata() {
	teamsMetadata.count = 0;
	teamsMetadata.nextIndex = 0;
	teamsMetadata.maxCount = 0;
	
	athletesMetadata.count = 0;
	athletesMetadata.nextIndex = 0;
	athletesMetadata.maxCount = 0;
	
	competitionsMetadata.count = 0;
	competitionsMetadata.nextIndex = 0;
	competitionsMetadata.maxCount = 0;
}

// this code creates the interactive shell
// you do not need to modify this
// You do not need to understand this code
// but you are welcome to research its application
void cmd_loop() {
	char input[MAX_INPUT_SIZE];
    ssize_t bytes_read;
	printf("Usage: \n");
	printf("setup {table} {numRows}\n");
	printf("insert {table} {data}\n");
	printf("delete {table} {id}\n");
	printf("modify {table} {id} {data}\n");
	printf("get {table}\n\n");
	initializeMetadata();
    while (1) {
        printf("CS211> ");
		fflush(stdout);
        
        // Read user input using the read() system call
        bytes_read = read(STDIN_FILENO, input, sizeof(input));
        
        if (bytes_read == -1) {
            perror("read");
            exit(EXIT_FAILURE);
        }
        
        if (bytes_read == 0) {
			printf("\n");
            break;
        }
        
        // Null-terminate the input	
        input[bytes_read] = '\0';

		char** args = (char**)malloc(MAX_ARGS_SIZE * sizeof(char*));
		int arg_count;

		splitInput(input, args, &arg_count);
        
        // Execute the user's command
        execute_cmd(args, arg_count);
		free(args);
    }
}


int main() {
	cmd_loop();
}
#include<sys/wait.h>
#include "./execution.h"
#include "./univ.h"
/**
* this function will execute a program, and write to the file descriptors
* specified by the user. 
* @args args which contains the program to be executed.
* @args inputfd the input file descriptor specified by caller
* @args outputfd the output file descriptor specified by caller
* @return the status code if program was run successfully, or -1 in certain circumstances
*/
unsigned int execute_command(char* args[], int inputfd, int outputfd) {
    int TempO = dup(STDOUT_FILENO);
    int TempI = dup(STDIN_FILENO);
    dup2(outputfd, STDOUT_FILENO);
    dup2(inputfd, STDIN_FILENO);
    pid_t process = fork();
    if (process < 0) {
        perror("Fork died D-:");
        exit(EXIT_FAILURE);
    } else if (process == 0) {
        execv(args[0], args);
        perror("Execution failed, It's joever");
        exit(EXIT_FAILURE);
    } else {
		int statuscode;
		waitpid(process,&statuscode,0);
        dup2(TempO, STDOUT_FILENO);
        dup2(TempI, STDIN_FILENO);
        close(TempO);
        close(TempI);
		return statuscode;
    }
	return -1;
}

/**
* A dummy main function to illustrate what the caller should look like. 
* Shows how Redirection and piping works with the execute function. 
* @arg argc, number of arguments user passes in
* @arg argv, an array of arguments user passes in. 
* @return exit status, depending on whether code succeeds or fails. 
*/
static int testmain(int argc, char** argv) {

	//===================simulating redirection with STDOUT========================
    int outputfile = open("./output.txt", O_CREAT | O_TRUNC | O_WRONLY, 0640);
    if (outputfile == -1) {
        perror("Failed to open output file, sorry");
        exit(EXIT_FAILURE);
    }

    char* myargs[] = {"/bin/ls", "-l", NULL};
    execute_command(myargs, STDIN_FILENO, outputfile);
    close(outputfile);
	
	//====================simulating redirection with STDIN.======================
	int inputfile = open("./input.txt", O_RDONLY);
	if(inputfile == -1){
		perror("invalid file");
		exit(EXIT_FAILURE);
	}
	char* myargs2[] = {"./sum",NULL};
	execute_command(myargs2,inputfile,STDOUT_FILENO);
	close(inputfile);
	//=======================simulating ls -l | grep .c==========================
	int afd[2];
	int status = pipe(afd);
	if(status == -1){
		perror("it's capy");
		exit(EXIT_FAILURE);
	}
	//myargs has ls stuff
	char* grepstuff[] = {"/bin/grep",".c",NULL};
	execute_command(myargs,STDIN_FILENO,afd[1]);
	close(afd[1]);
	execute_command(grepstuff,afd[0],STDOUT_FILENO);
	close(afd[0]);
    return 0;
}
//===================this file just holds the backup for the old execute thing=====================

void run_program(char** program) {
    pid_t p;
    //gotta have detection for "|", "<", and ">"
    //and values to hold their locations
    //if a pipe exists in the array
    short pipe_status = 0;
    //if a pipe exists, this is the pipes location
    short pipe_index = 0;
    //if a input redirect exists in the array
    short input_status = 0;
    //if a input redirect exists, this is the location
    short input_index = 0;
    //if a output redirect exists in the array
    short output_status = 0;
    //if a output redirect exists, this is the location
    short output_index = 0;

    //just a check to see what which returns
    // char* react = which(program[0],0);
    // printf("This is the react: %s\n", react);


    //check how many arguments were passed in
    short argc = 0;
    while (program[argc] != NULL) {
        argc++;
    }
    if(hasredirection(program,argc) != -1){ //shows it has redirection.
		pipe_status = 1;
		pipe_index = hasredirection(program,argc);
		char timmyepiccool[20];
		int length = 0;
		length = snprintf(timmyepiccool, sizeof(timmyepiccool), "%d", pipe_index);
		write(STDOUT_FILENO,timmyepiccool,length);
    }

    //check if wildcard was passed in
    int wildcard_status = 0;
    for (int i = 1; i < argc; i++) {
        //check if the wild card is found in the argument
        if (strchr(program [i], '*') != NULL) {
            wildcard_status = 1;
            break;
        }
    } 
    //now check if that wildcard is a bluff. I could put this in the above loop but I am lazy
    //(check if the glob count is 0)
    if (wildcard_status) {
        glob_t globbycheck;
        glob(program[1], GLOB_ERR, NULL, &globbycheck);
        if (globbycheck.gl_pathc == 0) {
            //printf("No matching files found\n");
                wildcard_status = 0;
        }
        globfree(&globbycheck);
    }


    //if a pipe exists, run the program with a pipe

    //when there is no wildcard run the program normally with fork
    //wildcard = 0
    if (!wildcard_status) {
        p = fork();
        if (p == -1) {
            perror("fork");
            exit(EXIT_FAILURE);
        } else if (p == 0) {
            //run the child processs
            char* executable = which(program[0],0);
            //exit if the executable is NULL
            if (executable == NULL) {
                perror("Passed in executable is NULL\n");
                exit(EXIT_FAILURE);
            }
            execv(executable,program);
            perror("error");
        } else {
            wait(NULL);
        }
    } 
    //run the parent
    //wild card = 1
    else {
        //storing the results of the glob from the wildcard
        glob_t globby;
        
        //do glob error handling
        //if this returns 0 then we are good
        if (glob(program[1], GLOB_ERR, NULL, &globby) != 0) {
            perror("glob");
            exit(EXIT_FAILURE);
        }

        for (int i = 0; i < globby.gl_pathc; i++) {
            p = fork();
            if (p == -1){
                perror("fork");
                exit(EXIT_FAILURE);
            } else if (p == 0) { //run the child! 
                char* argv[argc + 1];
                argv[0] = program[0]; //the name of the program being stored in the array
                //add the first matching name to the array
                argv[1] = globby.gl_pathv[i];
                argv[2] = NULL; //have a "null terminator" in the array

                //find the program
                char* executable = which(program[0],0);

                execv(executable,argv);
                perror("execv");
                exit(EXIT_FAILURE);
            } else {
                wait(NULL);
            }
        }
        //then we must free the glob we created
        //thats so cool that globs dynamically malloc themselves
        globfree(&globby);
    }
}
#include <dirent.h>
#include <string.h>
#include <sys/stat.h>
#include <limits.h>
#include <sys/types.h>
#include <signal.h>
#include <glob.h>

#include "./parser.h"

//=======universal
#include "./univ.h"

#define BUFFER_SIZE 4096

//toggle debugging mode
#ifndef DEBUG
#define DEBUG 0
#endif
//the big 3 directories we will use to find programs
//should be checked sequentially for programs
//ONLY used when the first argument is NOT a built-in function or if the "/" is not present
char* DirectoryOne = "/usr/local/bin";
//ONLY used when the first argument is NOT a built-in function or if the "/" is not present
char* DirectoryTwo = "/usr/bin";
//ONLY used when the first argument is NOT a built-in function or if the "/" is not present
char* DirectoryThree = "/bin";


/////////////////////////built-in commands that need to be implemented:
//pwd, which, exit, cd

//moves you from current working directory to designated path
void cd(const char *path) {
    if (chdir(path) == -1) {
        perror("cd");
    }
}

char* mystrdup(char* word){
    unsigned length = strlen(word);
    char* toreturn = (char*)malloc(sizeof(char) * length + 1);
    strcpy(toreturn,word);
    return toreturn;
}
//searches the directory for the given program with the provided path
char* search_directory(const char *path, const char *program, char flag) {
    if(DEBUG){
        write(STDOUT_FILENO,path,strlen(path));
        write(STDOUT_FILENO,"\n",1);
    }
    //will hold the path to the program if found
    char* toreturn = NULL;
    //stores the directory as a directory stream object
    DIR* directory;
    //stores the entry of the directory
    struct dirent *entry;
    //stores the information of the file
    struct stat info;

    //open the directory with the given path
    directory = opendir(path);

    //check if the directory is NULL
    if (directory == NULL) {
        perror("opendir");
        return toreturn;
    }

    //attempt traversal of the directory
    while ((entry = readdir(directory)) != NULL) {
        char full_path[BUFFER_SIZE];
        strcpy(full_path, path);
        strcat(full_path,"/");
        strcat(full_path, entry->d_name);
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        // Once the correct directory is found, proceed to saving the program path
        if (strcmp(entry->d_name, program) == 0) {
            if(flag){
            write(STDOUT_FILENO, full_path, strlen(full_path));
            write(STDOUT_FILENO, "\n", 1); // Add newline
            }
            //save the path to the program
            toreturn = mystrdup(full_path);
            closedir(directory); // Close directory since program is found
            return toreturn; // Exit the function
        }
    }

    // Close the directory
    closedir(directory);
    return toreturn;
}

/**
* Performs which, checking specific directories for the program
* @arg program - a string containing the program name
* @arg flag - set to 0 if you don't want directory printed, not 0 otherwise. 
* @return a string containing the full filepath. 
*/
char* which(const char *program, char flag) {
    char* toreturn = NULL;
    if (!DEBUG) {
        toreturn = search_directory(DirectoryOne, program, flag);
        if (toreturn == NULL) {
            toreturn = search_directory(DirectoryTwo, program, flag);
            if (toreturn == NULL) {
                toreturn = search_directory(DirectoryThree, program, flag);
            }
        }
    } else {
        search_directory(".", program, flag);
    }
    return toreturn;
}

//prints the working directory
void pwd() {
    char buf[BUFFER_SIZE];

    if (getcwd(buf, sizeof(buf)) != NULL) {
        write(STDOUT_FILENO, buf, strlen(buf));
        //add a new line to be extra
        write(STDOUT_FILENO, "\n",1);
    } else {
        perror("getcwd() error");
        return 1;
    }

    return 0;
}

//quits the shell program
void shell_exit() {
    write(STDOUT_FILENO,"its so hard to say goodbye :(\n",31);
    exit(0);
}
////////////////////////
int hasredirection(char** array, int numargs){
    for(int i = 0; i < numargs; i++){
        if(!strcmp(array[i],"|") || !strcmp(array[i],">") || !strcmp(array[i],"<")) return i;
    }
    return -1;
}
int handleredirection(char** commandlist, int numargs, int location) {
    if (location >= numargs - 1 || location < 1) {
        char* errorstring = "Error: improper redirect location\n";
        write(STDERR_FILENO, errorstring, strlen(errorstring));
        return -1;
    }

    if (strcmp(commandlist[location], "<") == 0) {
        char* commands[location + 1];
        char* newfilepath = which(commandlist[0], 0);
        if (newfilepath != NULL) {
            commands[0] = newfilepath;
        } else {
            commands[0] = commandlist[0];
        }
        free(newfilepath);
        for (int i = 1; i < location; i++) {
            commands[i] = commandlist[i];
        }
        commands[location] = NULL;
        int inputfd = open(commandlist[location + 1], O_RDONLY);
        if (inputfd == -1) {
            perror("error");
            return -1;
        }
        int statuscode = execute_command(commands, inputfd, STDOUT_FILENO);
		if(newfilepath != NULL) free(newfilepath);
		return statuscode;
    } else if (strcmp(commandlist[location], ">") == 0) {
 
	  char* commands[location + 1];
	  char* mycommands = which(commandlist[0],0);
	  if(mycommands != NULL){
		commands[0] = mycommands;
	  }
	  else{
		  commands[0] = commandlist[0];
	  }
	  for(int i = 1; i < location; i++){
		commands[i] = commandlist[i];
	  }
	  commands[location] = NULL;
	  int outputfd = open(commandlist[location + 1],O_CREAT | O_TRUNC | O_WRONLY,0640);
	  if(outputfd == -1){
		perror("");
		return -1;
	  }
	  int statuscode = execute_command(commands,STDIN_FILENO,outputfd);
	  if(mycommands != NULL) free(mycommands);
	  
    } else { 
        // Pipe case
        int pipefd[2];
        pipe(pipefd);
        int numargsize = location + 1;
        
        // Populate left arguments
        char* leftargs[numargsize];
        for (int i = 0; i < numargsize; i++) {
            leftargs[i] = commandlist[i];
        }
        leftargs[numargsize - 1] = NULL;
        
        // Populate right arguments
        numargsize = numargs - location - 1;
        char* rightargs[numargsize];
        for (int i = location + 1; i < numargs; i++) {
            rightargs[i - location - 1] = commandlist[i];
        }
        rightargs[numargsize - 1] = NULL;
        
        int toreturn;
        
        // Execute left command
        toreturn = execute_command(leftargs, STDIN_FILENO, pipefd[1]);
        close(pipefd[1]);
        
        // Execute right command
        toreturn = execute_command(rightargs, pipefd[0], STDOUT_FILENO);
        close(pipefd[0]);
        
        return toreturn;
    }
}
//function that runs programs with fork -> check myshbak.c
int run(char** commandlist, int numargs){
	int checkboi = hasredirection(commandlist,numargs);
	if(checkboi != -1){
		return handleredirection(commandlist,numargs,checkboi);
	}
	char* myarray[numargs + 1];
	char* returnpath = which(commandlist[0],0);
	if(returnpath != NULL){
		myarray[0] = returnpath;
	}
	else{
		myarray[0] = commandlist[0];
	}
	for(int i = 1; i < numargs; i++){
		myarray[i] = commandlist[i];
	}
	myarray[numargs] = NULL;
	pid_t process = fork();
	if(!process){
		execv(myarray[0],myarray);
		
	}
	else{
		int statusnum;
		waitpid(process,&statusnum,0);
		if(returnpath != NULL) free(returnpath);
		return statusnum;
	}
}
void goodbye(){
    write(STDOUT_FILENO,"\nYou pressed control + c, goodbye!\n",strlen("\nYou pressed control + c, goodbye!\n"));
    exit(0);
}
int main (int argc, char** argv) {
    //need the values for the first round so batch mode can grab from it
    // struct data* capybara = capygetline(STDIN_FILENO);
    // int data = capybara->size;
    // char** joever = capybara->myarray;

    //Enter Batch Mode
    //Pee in my pants
    signal(SIGINT, goodbye);
    if ((!isatty(STDIN_FILENO) && argc == 1) || argc == 2) {
        printf("I am in batch mode?!?!?!");
        //attempt to open file and see if it exits
        int file;
        file = open(argv[1], O_RDONLY);
        parserconstruct(file);
        if (file==-1) {
            perror(argv[1]);
        }
    } 
    //Enter Interactive Mode
    if(argc == 1 && isatty(STDIN_FILENO)) {
        //print the welcome statement for interactive mode
        write(STDOUT_FILENO,"Welcome to my fiendish little bomb\n",36);
        //have a loop for our shell

        parserconstruct(STDIN_FILENO);
        while(1){ 
            write(STDOUT_FILENO,"mysh>",5);
            char* commands = readline();
            int numberofcommands = 0;
            char* mycommand = " ";
            char* commandlist[100];
            memset(commandlist,0,sizeof(commandlist));
            splitInput(commands, commandlist, &numberofcommands);
            //if first entry matches built in commands

            if (!strcmp(commandlist[0], "exit")) {
            shell_exit();
            } else if (!strcmp(commandlist[0], "cd")) {
            cd(commandlist[1]);
            } else if (!strcmp(commandlist[0], "which")) {
            char* react = which(commandlist[1],1);
            } else if (!strcmp(commandlist[0], "pwd")) {
            pwd();
            }
            else{
                run(commandlist,numberofcommands);
            }

            //if first entry matches programs in directories
            //not a built in command
            

            //command does not match any known program
            //does not match built-in commands nor found through traversal





            free(commands);
        }
    }

    return 0;
}
// @@@@@@@@@@@@@@@@@@@@@ &&%%%%%%&&...&&   .,#%%%%%%%%%%%@     .....%@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@&&@&(,**..,     /....  ....(%%%%%%%%%%, ........@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@&,,,,(.../       %   . , ..... &%%%%%%%%# .......*@@@@@@@@@@@@
// @@@@@@@@@@@@@@@&&,....*  ./        (,%      ,...... %#%%&&&&  .......@@@@@@@@@@@
// @@@@@@@@@@@@@@%.. ...%              ,,,(      *   .   &%&&&&&,   ....,%@@@@@@@@@
// @@@@@@@@@@@@@.           .            ...       .       %&&&&&/    ...,&@@@@@@@@
// @@@@@@@@@@@@                            .        .        @&&@@*    ...,&@@@@@@@
// @@@@@@@@@@@                                               .%@@@%*......,,@@@@@@@
// @@@@@@@@@@         ,    %   .                      ...    ..*@@@.#.....,,@@@@@@@
// @@@@@@@@@&   .     (  .(&.                      . ...........#@@,*,..,,,,*@@@@@@
// @@@@@@@@@          & ..&&&          .  ,        ..............@@,**...,,,,@@@@@@
// @@@@@@@@&   ,      % .&%%%&           .  .       ............,.@,,*#...,,,&@@@@@
// @@@@@@@@#          #(*&%%%%&. .           /.   , ....,.........&/,*,.,,,,**@@@@@
// @@@@@@@@(  .   .    &&&&%%%%%,.&            ,.,  ,...,........../,,,,.,.,*/@@@@@
// @@@@@@@@# *.% ... . (&&&&&%%%%&,*,      .   , ..,.#.......,..,..(.,,/.*,&*#&@@@@
// @@@@@@@@@. ..%*..    %%&&%%%%%%%%&&(        ... ..*..,....,,,.*./.,,(,*(@*@@@@@@
// @@@@@@@@@.@. %*(      %&&%%%#(((###&&&   .  .*/.., (.,,..,,,,,#./,,,*,*@@/@@@@@@
// @@@@@@@@@/@&# ./(,  *&% %&&&&&.      ..//..#,,..**(#*(*.,,,,*,(./,,,/,&@@@@@@@@@
// @@@@@@@@@@@@@  /,..  ,,%%&                  /.(/**,#...,,,***((**,,/,*(@@@@@@@@@
// @@@@@@@@@@@@@@*(@ .,.%#,         .             **(.*..,,***#((/**/,#*@@@@@@@@@@@
// @@@@@@@@@@@@@@@/(@&,..,**(                        %....***/((/**/@&*@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@,,,*****      ....          //%...(%//(%/&(@@@&@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@&@@@@%*(&,*&(/             ////*/.&@#%@&%@%@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@,     &(((.   /*@@@%@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@&//*&&@@@@@@@@@@@@@@@@@@%@*              @&&@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@*,##%%%%%*//(&@@@@@@@@@@@@@@%%&%%%%%%%%%%%%%%%%&@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@*,,#######%%%%(/((##&@@@@@@@%////&&&&&&&&&&&&&&%&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// /*,/#########%%%%%###%%#///*(%%%%%&#(%&&&&&&&&%%@&&&%%@@@@@@@@@@@@@@@@*#%%&@@@@@
// **(/####%%%%%%%%%%%%%%%&&#%%%%#%&#&&%%#&&%%%%&&&&&%%@%%&//&@@/,,,,,,,(#%###%&@@@
// /(*#%%%%%%%%%%%%%%%%%%%%&#&&%###&&%%&&%%%%%%&&&%%%%&%%%%%#(((#**,,,*######%%%%@@
// /*###########%&&&&&&&&&&&%&#&&&%&&&%%%&&&&&%%%%%%%%%%%%%%%%####(/&###%%%%%%%%%&&
// */##%%%%%%%%##%%%%%%%%%@&&&&&##&&&&&%%%%&&&&&%%&%%%%&%%%%%%%%%##&//##%%%%%%%%&&&

#include<fcntl.h>
#include<unistd.h>
#include<string.h>
#include "./parser.h"
/**
 *this function will split the input string into an array of words. 
 *@arg input string we're splitting
 *
 */
void splitInput(char* input, char** args, int* arg_count) {
    *arg_count = 0;
    int in_quotes = 0; // Flag to track whether we are inside quotes
    char* token_start = input;

    for (char* ptr = input; *ptr != '\0'; ptr++) {
        if (*ptr == '"') {
            in_quotes = !in_quotes; // Toggle the in_quotes flag when a quote is encountered
        }

        if ((*ptr == ' ' || *ptr == '\n') && !in_quotes) {
            // If not inside quotes and a space or newline is found, consider it as a separator
            *ptr = '\0'; // Replace space or newline with null terminator
            args[(*arg_count)++] = token_start;
            token_start = ptr + 1; // Start of the next token
        }
    }

    // Add the last token (if any) after the loop
    if (*token_start != '\0') {
        // Remove leading and trailing double quotes if they exist
        if (token_start[0] == '"' && token_start[strlen(token_start) - 1] == '"') {
            token_start[strlen(token_start) - 1] = '\0'; // Remove trailing quote
            args[(*arg_count)++] = token_start + 1; // Remove leading quote
        } else {
            args[(*arg_count)++] = token_start;
        }
    }
    args[*arg_count] = NULL;
}

struct data* capygetline(int fd){
    char buffer[1024];
    memset(buffer,0,1024);
    write(STDOUT_FILENO,"mysh> ",6);
    int boi = read(fd,buffer,1024);
    char** myarray = malloc(sizeof(char*) * 100);
    int length;
    splitInput(buffer,myarray,&length);
    struct data* toreturn = malloc(sizeof(struct data));
    toreturn->myarray = myarray;
    toreturn->size = length;
    return toreturn;
}
#include <string.h>
#include "./univ.h"
int fd = -1;
char wasopened = 1;
char aoeustdin = 0;

/**
 *  this is our function that'll read one line from the fd specified by the user
 */
char* readline() {
    if(fd == -1){
        write(STDERR_FILENO,"Error: file descriptor not specified\n",strlen("Error: file descriptor not specified\n"));
        return NULL;
    }
    char buf;
    char* buffer = calloc(sizeof(char), 100);
    if (buffer == NULL) {
        write(STDERR_FILENO,"Memory allocation failed",25);
        return NULL;
    }
    

    size_t bytesRead;
    bytesRead = read(fd, buffer, 100);

    if (bytesRead == 0) {
        free(buffer);
        return NULL; // Return NULL if end of file is reached
    }
    return buffer;
}

char* mystrdup2(char* str){
    unsigned int length = strlen(str);
    char* toreturn = calloc(sizeof(char) , length + 1);
    strcpy(toreturn,str);
    return toreturn;
}
//char** tokenize_string(char *str, const char *delim, int *num_tokens)

void splitInput(char* input, char** args, int* arg_count) {
    *arg_count = 0;
    int in_quotes = 0; // Flag to track whether we are inside quotes
    char* token_start = input;

    for (char* ptr = input; *ptr != '\0'; ptr++) {
        if (*ptr == '"') {
            in_quotes = !in_quotes; // Toggle the in_quotes flag when a quote is encountered
        }

        if ((*ptr == ' ' || *ptr == '\n') && !in_quotes) {
            // If not inside quotes and a space or newline is found, consider it as a separator
            *ptr = '\0'; // Replace space or newline with null terminator
            args[(*arg_count)++] = token_start;
            token_start = ptr + 1; // Start of the next token
        }
    }

    // Add the last token (if any) after the loop
    if (*token_start != '\0') {
        // Remove leading and trailing double quotes if they exist
        if (token_start[0] == '"' && token_start[strlen(token_start) - 1] == '"') {
            token_start[strlen(token_start) - 1] = '\0'; // Remove trailing quote
            args[(*arg_count)++] = token_start + 1; // Remove leading quote
        } else {
            args[(*arg_count)++] = token_start;
        }
    }
    args[*arg_count] = NULL;
}

void parserconstruct(int ofd) {
    
    fd = dup(ofd);
    if(fd == STDIN_FILENO){
        aoeustdin = 1;
    }


}

